"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[6461],{2008:(e,i,o)=>{o.r(i),o.d(i,{assets:()=>a,contentTitle:()=>n,default:()=>h,frontMatter:()=>s,metadata:()=>d,toc:()=>l});var t=o(4848),r=o(8453);const s={},n="Introduction",d={id:"guides/node-operators/exits/introduction",title:"Introduction",description:"Lido V2 protocol upgrade adds support for Ethereum Withdrawals and introduces additional responsibilities for Node Operators.",source:"@site/docs/guides/node-operators/exits/introduction.md",sourceDirName:"guides/node-operators/exits",slug:"/guides/node-operators/exits/introduction",permalink:"/lido-docs-spanish/guides/node-operators/exits/introduction",draft:!1,unlisted:!1,editUrl:"https://github.com/adminseedlatam/lido-docs-spanish/edit/main/docs/guides/node-operators/exits/introduction.md",tags:[],version:"current",frontMatter:{},sidebar:"docs",previous:{title:"Execution Layer Rewards Configuration",permalink:"/lido-docs-spanish/guides/node-operators/el-rewards-configuration"},next:{title:"General Information",permalink:"/lido-docs-spanish/guides/node-operators/exits/general-information"}},a={},l=[{value:"Requirements",id:"requirements",level:2},{value:"Lido Tooling",id:"lido-tooling",level:2},{value:"Keys API (KAPI for short)",id:"keys-api-kapi-for-short",level:3},{value:"Validator Ejector (Ejector for short)",id:"validator-ejector-ejector-for-short",level:3}];function c(e){const i={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(i.h1,{id:"introduction",children:"Introduction"}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.a,{href:"https://blog.lido.fi/introducing-lido-v2/",children:"Lido V2"})," protocol upgrade adds support for ",(0,t.jsx)(i.a,{href:"https://ethereum.org/en/staking/withdrawals/",children:"Ethereum Withdrawals"})," and introduces additional responsibilities for Node Operators."]}),"\n",(0,t.jsx)(i.p,{children:"Lido Withdrawals are happening in four stages:"}),"\n",(0,t.jsxs)(i.ol,{children:["\n",(0,t.jsx)(i.li,{children:"stETH holders request a withdrawal"}),"\n",(0,t.jsx)(i.li,{children:"Lido Oracles decide which Lido validators should be exited to fulfil the request and publish the list on-chain"}),"\n",(0,t.jsx)(i.li,{children:"Lido Node Operators exit these validators"}),"\n",(0,t.jsx)(i.li,{children:"stETH holders claim their ETH"}),"\n"]}),"\n",(0,t.jsx)(i.p,{children:"This means that Node Operators need a way to react quickly to protocol requests."}),"\n",(0,t.jsx)(i.p,{children:"The suggested method is to generate and sign exit messages ahead of time which will be sent out when needed by a special new daemon called the Validator Ejector."}),"\n",(0,t.jsx)(i.p,{children:"To understand for which validators to generate and sign exit messages, another new app called Keys API is introduced."}),"\n",(0,t.jsx)(i.h2,{id:"requirements",children:"Requirements"}),"\n",(0,t.jsx)(i.p,{children:"First, is running Lido tooling required?"}),"\n",(0,t.jsx)(i.p,{children:"Lido tooling is not required to use, but is recommended."}),"\n",(0,t.jsx)(i.p,{children:"The only requirement for Node Operators is to exit their validators in time after requested by the protocol."}),"\n",(0,t.jsxs)(i.p,{children:["For details, check out ",(0,t.jsx)(i.a,{href:"https://hackmd.io/@lido/HJYFjmf6s",children:"Validator Exits Policy"})," and ",(0,t.jsx)(i.a,{href:"https://research.lido.fi/t/lido-validator-exits-policy-draft-for-discussion",children:"Research Forum Discussion"}),"."]}),"\n",(0,t.jsx)(i.h2,{id:"lido-tooling",children:"Lido Tooling"}),"\n",(0,t.jsx)(i.h3,{id:"keys-api-kapi-for-short",children:"Keys API (KAPI for short)"}),"\n",(0,t.jsx)(i.p,{children:"KAPI is a service which stores and serves up-to-date information about Lido validators."}),"\n",(0,t.jsx)(i.p,{children:"It provides a very important function: it provides two endpoints, using which a Node Operator understands for which validators to generate and sign exit messages in advance."}),"\n",(0,t.jsx)(i.p,{children:"Under the hood, KAPI also automatically filters out validators which are exited already or are currently exiting."}),"\n",(0,t.jsx)(i.h3,{id:"validator-ejector-ejector-for-short",children:"Validator Ejector (Ejector for short)"}),"\n",(0,t.jsxs)(i.p,{children:["Ejector is a daemon service which monitors ",(0,t.jsx)(i.code,{children:"ValidatorsExitBusOracle"})," events and initiates an exit when required."]}),"\n",(0,t.jsx)(i.p,{children:"In messages mode, on start, it loads exit messages in form of individual .json files from a specified folder or an external storage and validates their format, structure and signature."}),"\n",(0,t.jsx)(i.p,{children:"It then loads events from a configurable amount of latest finalized blocks, checks if exits should be made and after that periodically fetches fresh events."}),"\n",(0,t.jsx)(i.p,{children:"In webhook mode, it simply fetches a remote endpoint when an exit should be made, allowing to implement JIT approach by offloading exiting logic to an external service and using the Ejector as a secure exit events reader."})]})}function h(e={}){const{wrapper:i}={...(0,r.R)(),...e.components};return i?(0,t.jsx)(i,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},8453:(e,i,o)=>{o.d(i,{R:()=>n,x:()=>d});var t=o(6540);const r={},s=t.createContext(r);function n(e){const i=t.useContext(s);return t.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function d(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:n(e.components),t.createElement(s.Provider,{value:i},e.children)}}}]);